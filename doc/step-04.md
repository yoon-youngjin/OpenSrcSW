# 원격 저장소

## 5.1 서버 저장소(=원격 저장소)
- [x] 서버 저장소는 로컬 저장소의 코드를 복제한 복사본
- [x] 깃의 **분산형 관리 체계**는 다수의 사람과 협업하는데 매력적
- [x] 기존에는 코드를 공유하려고 이메일, 외부 저장 장치 등을 이용했지만, 이제는 깃의 원격 저장소 주소만 알려 주면 모두 해결


## 5.2 깃허브 연동 및 원격 등록

### 로컬 저장소 연결
- [x] 원격 저장소에 연결하려면 먼저 로컬 저장소가 있어야 함
- [x] 로컬 저장소를 원격 저장소에 연결하는 방법은 크게 두 가지
  1. 새로운 로컬 저장소를 생성하고 원격 저장소를 연결하는 방법
  2. 기존 저장소를 연결하는 방법

### 원격 저장소의 리모트 목록 관리
- 깃은 원격 저장소(서버)를 관리하는데 remote 명령어를 사용
- 현재 연결된 원격 저장소 목록을 확인할 수 있음
- 깃은 복수의 원격 저장소를 연결하여 사용할 수 있음
> `git remote`
>
> `git remote -v`
> 
> `-v` 옵션을 같이 사용하여 저장소의 별칭 이름과 URL 확인 가능
<p align="center">
    <img src="https://user-images.githubusercontent.com/83503188/161977608-565eedb9-d29b-4569-aa15-c779bf7d7eff.png" width="600px">
</p>

- [x] fetch용 주소와 push용 주소
- [x] push는 서버로 전송하는 동작을 의미
- [x] fetch는 반대로 서버에서 가지고 오는 동작을 의미



### 원격 저장소에 연결

> `git remote add 원격저장소별칭 원격저장소URL`

### 별칭 이름 변경과 정보 
- [x] 별칭은 긴 문자열의 서버 주소를 대체
- [x] 등록된 서버의 별칭 이름은 다시 변경할 수 있음
> `git remote rename 변경전 변경후`

- [x] 원격 저장소의 좀 더 상세한 정보를 확인하고 싶다면 show옵션
> `git remote show 원격저장소별칭`

### 원격 서버 삭제
- [x] 등록된 원격 저장소는 rm옵션으로 삭제할 수 있음
> `git remote rm 원격저장소별칭`


## 5.3 서버 전송

- [x] push: 서버에 전송
> `git push 원격저장소별칭 브랜치이름`

## 5.4 자동으로 내려받기

### clone: 복제
- [x] 원격 서버를 정상적으로 복제
- [x] 복제 후 remote 명령어를 사용하여 원격 저장소 정보를 확인
- [x] remote로 획인하면 연결된 서버 설정들이 표시
> `git clone 저장소주소`

<p align="center">
    <img src="https://user-images.githubusercontent.com/83503188/161978171-82e8d462-c696-4c5e-a0b9-5eecdbf3da2f.png" width="600px">
</p>

### pull: 서버에서 내려받기
- [x] 복제는 원격 저장소에서 모든 내용을 한 번에 내려받음
- [x] 복제 후 **원격 저장소의 갱신된 내용을 추가로 내려 받으려면 pull명령어를 사용**해야 함
- [x] pull 명령어를 주기적으로 사용하면 최신 커밋 정보로 로컬 저장소를 유지할 수 있음
> `git pull`

## 5.5 수동으로 내려받기
- [x] 원격 저장소 내용을 내려받는 방법은 크게 **`pull(풀)`**과 **`fetch(페치)`** 두 가지임
- [x] 이 두 방법의 차이는 병합을 자동 처리하는지 여부임

### 자동 병합

- [x] 풀은 원격 서버에서 현재 커밋보다 더 최선 커밋 정보가 있을 때 내려받음
- [x] 내려받은 최신 커밋들을 현재 브랜치로 자동으로 병합 처리함
- [x] 병합은 원격 서버 파일과 로컬 파일을 하나로 합치는 과정
- [x] 혼자서 개발하는 프로젝트는 pull 명령어만으로도 편리하게 사용할 수 있음
- [x] 여러 개발자와 협업으로 코드를 작성할 때 pull 명령어가 자동으로 브랜치 병합을 하지 못하고 충돌이 발생하기도 함
- [x] pull 명령어로 자동 병합을 하지 못할 때는 fetch 방식을 사용해야 함 

### fetch: 가져오기
- [x] fetch는 원격 저장소에서 코드를 **수동으로 내려받는 작업**을 함
- [x] fetch는 원격 저장소에서 커밋 된 코드를 임시 브랜치로 내려받음
- [x] 내려받은 후 현재 브랜치와 자동 병합하지 않음
> `git fetch 원격저장소URL`
> 
> 기존의 내용과 다른 내용이 있는 경우 서버에서 가져와서 바로 병합하지 않음
- [x] fetch후 git log를 확인해도 새로운 commit 내용 x
- [x] fetch는 임시 저장소에 commit을 가져다놓음
- [x] fetch는 원격 저장소의 커밋들만 가지고 왔을 뿐 로컬 저장소에서 어떤 작업도 하지 않음

### merge 명령어로 수동 병합
> `git merge 원격저장소별칭/브랜치이름`

<p align="center">
    <img src="https://user-images.githubusercontent.com/83503188/161978928-a32ddc77-60ca-4ca6-bdbf-88926ab7df40.png" width="600px">
</p>

## 5.6 순서
- [x] 원격 저장소에는 다수의 개발자가 동시에 커밋을 푸시할 수 없음
- [x] 여러 명이 협력해서 개발할 때는 순차적으로 푸시해야 함

### 최신 상태
- [x] 원격 저장소에 푸시하려면 **로컬 저장소를 최신 상태**로 유지
- [x] 누군가 내 저장소보다 먼저 커밋하여 새로운 커밋으로 서버를 갱신한 경우
- [x] 간발의 차이로 갱신된 서버 정보를 가지고 있지 않음
- [x] 푸시는 서버의 마지막 커밋과 푸시되는 커밋을 병합
- [x] 이때 내 커밋은 서버의 최신 커밋보다 늦은 커밋으로 밀리게 됨
- [x] 커밋이 순차적이지 않을 때 깃은 푸시 동작을 거부
- [x] 푸시 동작이 거부되면 풀 또는 페치 작업으로 자신의 로컬 저장소를 갱신(`pull`)해 주어야 함
- [x] 갱신 후에 다시 푸시

### 충돌 방지
- [x] 깃이 최신 상태에서만 푸시를 허용하는 것은 충돌을 방지하기 위해서임
- [x] 원격 저장소의 커밋을 내려받는 풀 작업은 내려받은 커밋들을 현재 브랜치로 자동 병합
- [x] 이때 커밋 내용이 순차적이지 않으면 병합 과정에서 충돌이 발생
<p align="center">
    <img src="https://user-images.githubusercontent.com/83503188/161979087-d0d3b59e-1104-4a9b-a811-baf609814738.png" width="600px">
</p>

